// About
/*
* Example program to draw a map of localization data.
* 
* The localization is supposed to be generated by the localization_node.cpp.
*/

#include <opencv2/opencv.hpp>
#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
#include <math.h>
#include <chrono>
#include <ctime>
#include <iomanip>
#include <stdlib.h>

#include "SharedParameters.h"
#include "GlobalEnumerationConstants.h"

using std::cout;
using std::endl;
using std::string;

#define PI 3.14159265

#ifndef CV_FILLED
#define CV_FILLED cv::FILLED
#endif

struct Point {
    int unixTimeStamp;
    float latitude;
    float longitude;
    int laneStatus;
    bool switchDetected = false;
    bool leftPoleDetected = false;
    bool rightPoleDetected = false;
};

float maxLatitude = -90;
float minLatitude = 90;
float maxLongitude = -180;
float minLongitude = 180;

float mapX;
float mapY;
float mapW;
float mapH;

std::vector<Point> pointVector;

bool animateDrawing = true; // animate the creation of the map

/*
* Reads a text file containing localization data that have been generated by the ROS node localization_node.
*/
void ReadFile(){
    string localizationFilePath = pathToVisionSystem + "../Localization/localization.txt";

    string line;
    std::ifstream file (localizationFilePath);
    if (file.is_open())
    {
        while ( std::getline (file, line) ){
            Point point;
            point.unixTimeStamp = std::stoi(line);
            std::getline(file, line);
            point.latitude = std::stof(line);
            maxLatitude = std::max(maxLatitude, point.latitude);
            minLatitude = std::min(minLatitude, point.latitude);
            
            std::getline(file, line);
            point.longitude = std::stof(line);
            maxLongitude = std::max(maxLongitude, point.longitude);
            minLongitude = std::min(minLongitude, point.longitude);
            
            std::getline(file, line);
            point.laneStatus = std::stoi(line);

            while (std::getline(file, line) && line != "") {
                if (line == "S") {
                    point.switchDetected = true;
                }
                else if (line == "L") {
                    point.leftPoleDetected = true;
                }
                else if (line == "R"){
                    point.rightPoleDetected = true;
                }
            }
            pointVector.push_back(point);
        }
        file.close();

        // Calculate the size of the map
        mapY = minLatitude - (maxLatitude - minLatitude) * 0.1;
        mapX = minLongitude - (maxLongitude - minLongitude) * 0.1;
        mapH = (maxLatitude - minLatitude) * 1.2;
        mapW = (maxLongitude - minLongitude) * 1.2;
    }
    else {
        cout << "File was not found!" << endl;
    }
}

/*
* Draw a map containing localization data
*/
void DrawMap() {
    // Scaling
    const double kilometerToLongitudeConversationFactor = 0.0168; // Length in meters of 1° of longitude = 40075 km * cos(latitude) / 360
    const double kilometerToLatitudeConversionFactor = 0.009; // Length in meters of 1° of latitude = always 111.32 km
    float mapWKilometer = (mapW / kilometerToLongitudeConversationFactor);
    float mapHKilometer = (mapH / kilometerToLatitudeConversionFactor);

    float widthHeightFraction = mapWKilometer / mapHKilometer;
    int mapHeight = 720;
    int mapWidth = mapHeight * widthHeightFraction;
    cv::Size mapSize(mapWidth, mapHeight);
    int lineThickness = 2;
    cv::Scalar lineColor = cv::Scalar(0, 0, 0);

    cv::Mat map(mapSize, CV_8UC3, cv::Scalar(255, 255, 255));
    cv::waitKey(0);

    // Draw compass
    cv::arrowedLine(map, cv::Point(mapWidth - 90, mapHeight - 30), cv::Point(mapWidth - 90, mapHeight - 75), cv::Scalar(0, 0, 0), 2, 8, 0, 0.15);
    cv::arrowedLine(map, cv::Point(mapWidth - 113, mapHeight - 52), cv::Point(mapWidth - 68, mapHeight - 52), cv::Scalar(0, 0, 0), 2, 8, 0, 0.15);
    cv::Size textSize = cv::getTextSize("N", cv::FONT_HERSHEY_COMPLEX_SMALL, 0.9, 1, 0);
    cv::putText(map, "N", cv::Point(mapWidth - 90 - textSize.width / 2, mapHeight - 80), cv::FONT_HERSHEY_COMPLEX_SMALL, 0.9, cv::Scalar(0, 0, 0), 1);
    cv::putText(map, "E", cv::Point(mapWidth - 65, mapHeight - 52 + textSize.height / 2), cv::FONT_HERSHEY_COMPLEX_SMALL, 0.9, cv::Scalar(0, 0, 0), 1);

    // Draw scale
    double distanceInKilometers = 0.1; // 100 meter scale
    int longitudeDistanceInPixels = (distanceInKilometers / mapWKilometer) * mapWidth;
    cv::line(map, cv::Point(50, mapHeight - 52), cv::Point(50 + longitudeDistanceInPixels, mapHeight - 52), cv::Scalar(0, 0, 0), 2);
    cv::line(map, cv::Point(50, mapHeight - 57), cv::Point(50, mapHeight - 47), cv::Scalar(0, 0, 0), 2);
    cv::line(map, cv::Point(50 + longitudeDistanceInPixels, mapHeight - 57), cv::Point(50 + longitudeDistanceInPixels, mapHeight - 47), cv::Scalar(0, 0, 0), 2);
    textSize = cv::getTextSize("100 m", cv::FONT_HERSHEY_COMPLEX_SMALL, 0.8, 1, 0);
    cv::putText(map, "100 m", cv::Point(50 + longitudeDistanceInPixels / 2 - textSize.width / 2, mapHeight - 58), cv::FONT_HERSHEY_COMPLEX_SMALL, 0.8, cv::Scalar(0, 0, 0), 1);

    // Draw localization data
    cv::Point point1 = cv::Point((pointVector[0].longitude - mapX) / mapW * mapSize.width, mapSize.height - (pointVector[0].latitude - mapY) / mapH * mapSize.height);
    cv::circle(map, point1, 10, cv::Scalar(0, 0, 255), -1); // start point
    cv::Point point2;
    cv::Point lastPosition;
    for (int iPoint = 1; iPoint < pointVector.size(); iPoint++){
        point2 = cv::Point((pointVector[iPoint].longitude - mapX) / mapW * mapSize.width, mapSize.height - (pointVector[iPoint].latitude - mapY) / mapH * mapSize.height);

        if (point1 != point2){
            lastPosition = point1;
        }
        
        cv::Point pointDifference = cv::Point(point2.x - lastPosition.x, point2.y - lastPosition.y);
        double angle = std::atan2((double)pointDifference.y, (double)pointDifference.x);

        if (pointVector[iPoint].laneStatus == LANE_STATUS::SINGLE_TRACK) {
            cv::line(map, point1, point2, cv::Scalar(0, 0, 255), lineThickness);
        }
        else if (pointVector[iPoint].laneStatus == LANE_STATUS::LEFT_TRACK) {
            cv::Point diff = cv::Point(std::cos(angle - PI / 2) * 4, std::sin(angle - PI / 2) * 4);
            cv::line(map, point1 + diff, point2 + diff, cv::Scalar(0, 0, 255), lineThickness);
            cv::line(map, point1 - diff, point2 - diff, lineColor, lineThickness);
        }
        else if (pointVector[iPoint].laneStatus == LANE_STATUS::RIGHT_TRACK) {
            cv::Point diff = cv::Point(std::cos(angle + PI / 2) * 4, std::sin(angle + PI / 2) * 4);
            cv::line(map, point1 + diff, point2 + diff, lineColor, lineThickness);
            cv::line(map, point1 - diff, point2 - diff, cv::Scalar(0, 0, 255), lineThickness);
        }
        else if (pointVector[iPoint].laneStatus == LANE_STATUS::MIDDLE_TRACK) {
            cv::Point diff = cv::Point(std::cos(angle + PI / 2) * 4, std::sin(angle + PI / 2) * 4);
            cv::line(map, point1 + diff, point2 + diff, lineColor, lineThickness);
            cv::line(map, point1, point2, cv::Scalar(0, 0, 255), lineThickness);
            cv::line(map, point1 - diff, point2 - diff, lineColor, lineThickness);
        }

        if (pointVector[iPoint].leftPoleDetected) {
            cv::Point newPoint = point2 + cv::Point(std::cos(angle - PI / 2) * 8, std::sin(angle - PI / 2) * 8);
            cv::drawMarker(map, newPoint, cv::Scalar(0, 125, 0), cv::MARKER_SQUARE, 10, 3);
        }
        if (pointVector[iPoint].rightPoleDetected) {
            cv::Point newPoint = point2 + cv::Point(std::cos(angle + PI / 2), std::sin(angle + PI / 2)) * 8;
            cv::drawMarker(map, newPoint, cv::Scalar(0, 125, 0), cv::MARKER_SQUARE, 10, 3);
        }
        if (pointVector[iPoint].switchDetected) {
            cv::drawMarker(map, point2, cv::Scalar(0, 125, 125), cv::MARKER_CROSS, 10, 3);
        }
        
        point1 = point2;

        if (animateDrawing) {
            // Then draw the time for the current position. Draw a white rectangle to remove old time text first. 
            const time_t time = (time_t)pointVector[iPoint].unixTimeStamp;
            std::string timeString(std::ctime(&time));
            timeString.pop_back();
            cv::Size const textSize = getTextSize(timeString, cv::FONT_HERSHEY_COMPLEX_SMALL, 0.9, 1, 0);
            cv::rectangle(map, cv::Point(10, 20 - textSize.height), cv::Point(10 + textSize.width, 20), cv::Scalar(255, 255, 255), CV_FILLED, 8, 0);
            cv::putText(map, timeString, cv::Point(10, 20), cv::FONT_HERSHEY_COMPLEX_SMALL, 0.9, cv::Scalar(0, 0, 0), 1);
        
            // Draw and wait
            cv::imshow("Map window", map);
            cv::waitKey(5);
        }
    }
    cv::circle(map, point1, 10, cv::Scalar(255, 0, 0), -1); // end point

    // Write image to disk
    string saveFilePath = pathToVisionSystem + "../Localization/localizationMap.jpg";
    cv::imwrite(saveFilePath, map);

    cv::imshow("Map window", map);
    cv::waitKey(0);
}


int main() {
    ReadFile();
    DrawMap();
    return 0;
}